<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  width: 45em;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 30px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><title>Chapter02.Strings and Text</title></head><body><article class="markdown-body"><h1 id="chapter02-strings-and-text"><a name="user-content-chapter02-strings-and-text" href="#chapter02-strings-and-text" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Chapter02. Strings and Text</h1>
<p><img alt="mind map of Strings and Text" src="///F://Learning/Python/Cookbook/Cookbook%20Note/Chapter02/Strings_and_Text.gif" /></p>
<h2 id="21-splitting-strings-on-any-of-mutiple-delimiters"><a name="user-content-21-splitting-strings-on-any-of-mutiple-delimiters" href="#21-splitting-strings-on-any-of-mutiple-delimiters" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.1 Splitting Strings on Any of Mutiple Delimiters</h2>
<ul>
<li>The <em>split()</em> method of string objects is really meant for very simple cases, and does not allow for multiple delimiters or account for possible whitespace around the delimiters.</li>
<li>In cases when you need a bit more flexibility, use the <em>re.split()</em> method.</li>
<li>Feed <em>re.split()</em> with regular expression pattern.</li>
<li>If capture groups <em>()</em> are used, then the matched text is also included in the result.</li>
<li>If you don&rsquo;t want the separator characters in the result, but still need parentheses to group parts of the regular expression pattern, make sure you use a noncapture group, specified as (?:).<br />
<pre><code class="python">line = 'asdf fjdk; afed, fjek,asdf,     foo'
import re
splits = re.split(r'[;,\s]\s*',line) # [] expression means &quot;or&quot;, '\s' means whitespace
splits2 = re.split(r'(;|,|\s)\s*', line)
print(splits) # ['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
print(splits2) # ['asdf', ' ', 'fjdk', ';', 'afed', ',', 'fjek', ',', 'asdf', ',', 'foo']

values = splits2[::2]
print(values) # ['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
delimiters = splits2[1::2] + ['']
print(delimiters) # [' ', ';', ',', ',', ',', '']

splits3 = re.split(r'(?:,|;|\s)\s*', line); # ['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
print(splits3)
</code></pre></li>
</ul>
<h2 id="22-matching-text-at-the-start-or-end-of-a-string"><a name="user-content-22-matching-text-at-the-start-or-end-of-a-string" href="#22-matching-text-at-the-start-or-end-of-a-string" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.2 Matching Text at the Start or End of a String</h2>
<ul>
<li>A simple way to check the beginning or end of a string is to use the str.<em>startswith()</em> or <em>str.endswith()</em> methods.</li>
<li>
<p>Oddly, this is one part of Python where a tuple is actually required as input. If you happen to have the choices specified in a list or set, just make sure you convert them using <em>tuple()</em> first.<br />
<pre><code class="python">import os
filenames = os.listdir('.')
print(filenames)
print([name for name in filenames if name.endswith(('.py','.markdown'))])

choices = ['http:', 'ftp:']
url = 'http://www.python.org'
print(url.startswith(tuple(choices))) # it must be tuple

# Result:
# ['Note.markdown', 'python-cookbook-master', 'python-cookbook-master.zip', 'test.py']
# ['Note.markdown', 'test.py']
# True
</code></pre></p>
</li>
<li>
<p>Similar operations can be performed with slices.<br />
<pre><code class="python">&gt;&gt;&gt; filename = 'spam.txt'
&gt;&gt;&gt; filename[-4:] == '.txt'
True
&gt;&gt;&gt; url = 'http://www.python.org'
&gt;&gt;&gt; url[:5] == 'http:' or url[:6] == 'https:' or url[:4] == 'ftp:'
</code></pre></p>
</li>
<li>
<p>You might also be inclined to use regular expressions as an alternative.<br />
<pre><code class="python">&gt;&gt;&gt; import re
&gt;&gt;&gt; url = 'http://www.python.org'
&gt;&gt;&gt; re.match('http:|https:|ftp:', url)
&lt;_sre.SRE_Match object; span=(0, 5), match='http:'&gt;
</code></pre></p>
</li>
</ul>
<h2 id="23-matching-strings-using-shell-wildcard-patterns"><a name="user-content-23-matching-strings-using-shell-wildcard-patterns" href="#23-matching-strings-using-shell-wildcard-patterns" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.3 Matching Strings Using Shell Wildcard Patterns</h2>
<ul>
<li>The <em>fmatch</em> moduel provides two functions &ndash; <em>fnmatch()</em> and <em>fnmatchcase()</em> &ndash; that can be used to perform such matching.</li>
<li><em>fnmatch()</em> matches patterns using the same case-sensitivity rules as the system&rsquo;s underlying filesystem, however, <em>fnmatchcase()</em> is case-sensitive.<br />
<pre><code class="python"># fnmatchcase function is case-sensitive
from fnmatch import fnmatch, fnmatchcase

print(fnmatch('Dat45.csv', 'Dat[0-9]*'))
names = ['Dat1.csv', 'Dat2.csv', 'config.ini', 'foo.py']
name_csv = [name for name in names if fnmatch(name, 'Dat*.csv')]
print(name_csv)

addresses = [
    '5412 N CLARK ST',
    '1060 W ADDISON ST',
    '1039 W GRANVILLE AVE',
    '2122 N CLARK ST',
    '4802 N BROADWAY'
]
print([addr for addr in addresses if fnmatchcase(addr, '* ST')])
print([addr for addr in addresses if fnmatchcase(addr, '54[0-9][0-9] *CLARK*')])

# Result
# True
# ['Dat1.csv', 'Dat2.csv']
# ['5412 N CLARK ST', '1060 W ADDISON ST', '2122 N CLARK ST']
# ['5412 N CLARK ST']
</code></pre></li>
</ul>
<h2 id="24-matching-and-searching-for-text-patterns"><a name="user-content-24-matching-and-searching-for-text-patterns" href="#24-matching-and-searching-for-text-patterns" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.4 Matching and Searching for Text Patterns</h2>
<ul>
<li>If the text you&rsquo;re trying to match is a simple literal, you can often just use the basic string methods, such as <em>str.find()</em>, <em>str.endswith()</em>, <em>str.startswith()</em>, or similar.</li>
<li>
<p>For more complicated matching, use <em>regular expressions</em> and the <em>re</em> module.<br />
<pre><code class="python"># match() function is trying to find matches at the beginning of strings
text1 = '1/21/2016'
text2 = 'Jan 21, 2016'

import re

def judge(text):
    if re.match(r'\d+/\d+/\d',text):
        print('yes')
    else:
        print('no')

judge(text1) # yes
judge(text2) # no
</code></pre></p>
</li>
<li>
<p>If you&rsquo;re going to perform a lot of matches using the same pattern, it usually pays to precompile the regular expression pattern into a pattern object first.</p>
</li>
<li>
<p><em>match()</em> always tries to find the match at the start of a string.<br />
<pre><code class="python">datepat = re.compile(r'\d+/\d+/\d')
def judge1(text):
    if datepat.match(text):
        print('yes')
    else:
        print('no')

judge1(text1) # yes
judge1(text2) # no
</code></pre></p>
</li>
<li>
<p>If you want to search text for all occurences of a pattern, use <em>findall()</em> method instead.<br />
<pre><code class="python"># findall() function
import re

text = 'Today is 1/21/2016. Tomorrow is 1/22/2016'
datepat = re.compile(r'\d+/\d+/\d+')
print(datepat.findall(text)) # ['1/21/2016', '1/22/2016'] (is a list)
</code></pre></p>
</li>
<li>
<p>When defining regular expressions, it is common to introduc capture groups by enclosing parts of the pattern in parentheses.<br />
<pre><code class="python">import re

datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
m = datepat.match('10/20/2016')
print(m.group(0))
print(m.group(1))
print(m.group(2))
print(m.group(3))
print(m.groups())

# 10/20/2016
# 10
# 20
# 2016
# ('10', '20', '2016')
</code></pre></p>
</li>
<li>
<p>If you want to find matches iteratively, use the <em>finditer()</em> method instead. <br />
<pre><code class="python">import re

text = 'Today is 1/21/2016. Tomorrow is 1/22/2016'
datepat = re.compile(r'(\d+)/(\d+)/(\d+)') # capture group
for m in datepat.finditer(text):
    print(m.groups())

#Result
# ('1', '1', '2016')
# ('1', '2', '2016')
</code></pre></p>
</li>
</ul>
<h2 id="25-searching-and-replacing-text"><a name="user-content-25-searching-and-replacing-text" href="#25-searching-and-replacing-text" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.5 Searching and Replacing Text</h2>
<ul>
<li>
<p>Use the <em>str.replace()</em> method.<br />
<pre><code class="python">#replace funtion
text = 'yeah, but no, but yeah, but no, but yeah'
text.replace('yeah', 'yep') # yep, but no, but yep, but no, but yep
</code></pre></p>
</li>
<li>
<p>For more comlicated patterns, use the <em>sub()</em> functions/methods in the <em>re</em> module.</p>
</li>
<li>
<p>Blackslashed digits such as <em>\3</em> refer to capture group numbers in the pattern.<br />
<pre><code class="python"># re.sub function.
import re

text = 'Today is 1/22/2016. Tomorrow is 1/23/2016'
replace1 = re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2',text)
print(replace1)

datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
replace2 = datepat.sub(r'\3-\1-\2', text)
print(replace2)

# Today is 2016-1-22. Tomorrow is 2016-1-23
# Today is 2016-1-22. Tomorrow is 2016-1-23
</code></pre></p>
</li>
<li>
<p>It&rsquo;s possible to specify a substitution callback function instead.<br />
<pre><code class="python"># Callback funtion
from calendar import month_abbr
def change_date(m):
    mon_name = month_abbr[int(m.group(1))]
    return '{} {} {}'.format(m.group(2), mon_name, m.group(3))

print(datepat.sub(change_date, text))

# Result
# Today is 22 Jan 2016. Tomorrow is 23 Jan 2016
</code></pre></p>
</li>
<li>
<p>If you want to know how many substitutions were made in addition to getting the replacement text, use <em>re.subn()</em> instead<br />
<pre><code class="python"># re.subn function
import re
text = 'Today is 1/22/2016. Tomorrow is 1/23/2016'
newtext, n = datepat.subn(r'\3-\1-\2',text)
print(newtext) # Today is 2016-1-22. Tomorrow is 2016-1-23
print(n) # 2
</code></pre></p>
</li>
</ul>
<h2 id="26-searching-and-replacing-case-insensitive-text"><a name="user-content-26-searching-and-replacing-case-insensitive-text" href="#26-searching-and-replacing-case-insensitive-text" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.6 Searching and Replacing Case-Insensitive Text</h2>
<ul>
<li>
<p>Use the <em>re</em> module and supply the re.IGNORECASE flag to various operations.<br />
<pre><code class="python">import re

text = &quot;UPPER PYTHON, lower python, Mixed Python&quot;
print(re.findall('python', text, flags = re.IGNORECASE))
print(re.sub('python', 'snake', text,flags = re.IGNORECASE))

# ['PYTHON', 'python', 'Python']
# UPPER snake, lower snake, Mixed snake```
</code></pre></p>
</li>
<li>
<p>To fix the limitation that replacing text won&rsquo;t match the case of the matched text.<br />
<pre><code class="python">import re

def matchcase(word):
    def replace(m):
        text = m.group()
        if text.isupper():
            return word.upper()
        elif text.islower():
            return word.lower()
        elif text[0].upper():
            return word.capitalize()
        else:
            return word
    return replace

text = 'UPPER PYTHON, lower python, Mixed Python'
result = re.sub('python', matchcase('snake'), text, flags = re.IGNORECASE)
print(result) #　UPPER SNAKE, lower snake, Mixed Snake
</code></pre></p>
</li>
</ul>
<h2 id="27-specifying-a-regular-expression-for-the-shortest-match"><a name="user-content-27-specifying-a-regular-expression-for-the-shortest-match" href="#27-specifying-a-regular-expression-for-the-shortest-match" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.7 Specifying a Regular Expression for the Shortest Match</h2>
<ul>
<li>This problem often arises in patterns that try to match enclosed inside a pair of starting and ending delimiters.</li>
<li>To fix this, add the <em>?</em> modifier after the * operator in pattern.<br />
<pre><code class="python">import re
str_pat = re.compile(r'\&quot;(.*)\&quot;')
text = 'Computer says &quot;no&quot;. Phone says &quot;yes&quot;'
print(str_pat.findall(text)) # Longest match

str_pat_optimize = re.compile(r'\&quot;(.*?)\&quot;')
print(str_pat_optimize.findall(text)) # Shortest match

# Result
# ['no&quot;. Phone says &quot;yes']
# ['no', 'yes']
</code></pre></li>
</ul>
<h2 id="28-writing-a-regular-expression-for-multiline-patterns"><a name="user-content-28-writing-a-regular-expression-for-multiline-patterns" href="#28-writing-a-regular-expression-for-multiline-patterns" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.8 Writing a Regular Expression for Multiline Patterns</h2>
<ul>
<li>Dot(.) doesn&rsquo;t match newlines.</li>
<li>
<p>Suppose you are trying to match C-style comments.<br />
<pre><code class="python">import re

comment = re.compile(r'/\*(.*?)\*/')
text1 = '/* this is a comment */'
text2 = ''' /* this is a
               multiline comment */
'''
print(comment.findall(text1)) # [' this is a comment ']
print(comment.findall(text2)) # []
</code></pre></p>
</li>
<li>
<p>To fix the problem, you can add support for newlines.</p>
</li>
<li>
<p>In this pattern,<em>(?:.|\n)</em> specifies a noncapture group (it defines a group for purposes of matching, but that group is not captured separately or numbered).<br />
<pre><code class="python">comment1 = re.compile(r'/\*(?:.|\n)*?\*/')
print(comment1.findall(text2)) # ['/* this is a\n               multiline comment */']
</code></pre></p>
</li>
<li>
<p>The <em>re.compile()</em> function accepts a flag, <em>re.DOTAIL</em>, which is useful here. It makes the dot(.) in a regular expression match all characters, including  newlines.<br />
<pre><code class="python">comment2 = re.compile(r'/\*(.*?)\*/', re.DOTALL)
print(comment2.findall(text1)) # [' this is a comment ']
print(comment2.findall(text2)) # [' this is a\n               multiline comment ']
</code></pre></p>
</li>
</ul>
<h2 id="29-normalizing-unicode-text-to-a-standard-representation"><a name="user-content-29-normalizing-unicode-text-to-a-standard-representation" href="#29-normalizing-unicode-text-to-a-standard-representation" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.9 Normalizing Unicode Text to a Standard Representation</h2>
<ul>
<li>
<p>In Unicode, certain characters can be represented by more than one valid sequence of code points.<br />
<pre><code class="python">s1 = 'Spicy Jalape\u00f1o'
s2 = 'Spicy Jalapen\u0303o'
print(s1) 
print(s2)
print(len(s1), len(s2))

# Result
# 'Spicy Jalapeño'
# 'Spicy Jalapeño'
# False
# 14 15
</code></pre></p>
</li>
<li>
<p>In order to fix this, you should first normalize the text into a standard representation using the <em>unicodedata</em> module.</p>
</li>
<li>NFC means that characters should be fully composed.</li>
<li>
<p>NFD means that characters shuold be fully decomposed with the use of combining characters.<br />
<pre><code class="python">import unicodedata
t1 = unicodedata.normalize('NFC', s1)
t2 = unicodedata.normalize('NFC', s2)
print(t1 == t2)
print(ascii(t1))

t3 = unicodedata.normalize('NFD', s1)
t4 = unicodedata.normalize('NFD', s2)
print(t3 == t4)
print(ascii(t3))


# True
# 'Spicy Jalape\xf1o'
# True
# 'Spicy Jalapen\u0303o'
</code></pre></p>
</li>
<li>
<p>Suppose you want to remove all diacritical marks from some text (possible for the purposes of searching and matching).</p>
</li>
<li>The <em>combining()</em> function tests a character to see if it is a combining character.<br />
<pre><code class="python">import unicodedata

s1 = 'Spicy Jalape\u00f1o'
t1 = unicodedata.normalize('NFD', s1)
print(''.join(c for c in t1 if not unicodedata.combining(c))) # Spicy Jalapeno
</code></pre></li>
</ul>
<h2 id="210-working-with-unicode-character-in-regular-expressions"><a name="user-content-210-working-with-unicode-character-in-regular-expressions" href="#210-working-with-unicode-character-in-regular-expressions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.10 Working with Unicode Character in Regular Expressions</h2>
<ul>
<li><em>\d</em> already matches any unicode digit character</li>
<li>Here is a regex that matches all characters in a few different Arabic code pages<br />
<pre><code class="python">arabic = re.compile('[\u0600-\u06ff\u0750-\u077f\u08a0-\u08ff]')
</code></pre></li>
</ul>
<h2 id="211-stripping-unwanted-characters-from-strings"><a name="user-content-211-stripping-unwanted-characters-from-strings" href="#211-stripping-unwanted-characters-from-strings" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.11 Stripping Unwanted Characters from Strings</h2>
<ul>
<li>The <em>strip()</em> method can be used to strip characters from the <strong>beginning or end</strong> of a string.</li>
<li><em>lstrip()</em> and <em>rstrip()</em> performing stripping from the left or right side, respectively.</li>
<li>If you needed to do something to the inner space, you would need to use another technique, such as using the <em>replace()</em> method or a regular expression substitution.<br />
<pre><code class="python">s = '   hello world \n'
print(s.strip())
t = '-----hello====='
print(t.lstrip('-'))
print(t.rstrip('='))
print(t.strip('-='))

# Result
# hello world
# hello=====
# -----hello
# hello
</code></pre></li>
</ul>
<h2 id="212-sanitizing-and-cleaning-up-text"><a name="user-content-212-sanitizing-and-cleaning-up-text" href="#212-sanitizing-and-cleaning-up-text" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.12 Sanitizing and Cleaning up Text</h2>
<ul>
<li>If you want to eliminate whole ranges of characters or strip diacritical marks, you can turn to the often overlooked <em>str.translate()</em> method.</li>
<li>You can take this remapping idea a step further and build much bigger tables.</li>
<li>Another technique for cleaning up text involves I/O decoding and encoding functions:The idea here is to first do some preliminary cleanup of the text, and then run it through a combination of <em>encode()</em> or <em>decode()</em> operations to strip or alter it.<br />
<pre><code class="python">s = 'p\xfdt\u0125\xf6\xf1\x0cis\tawesome\r\n'
print(s) # pýtĥöñis    awesome

# (a) Remapping whitespace
remap = {
    ord('\t') : ' ',
    ord('\f') : ' ',
    ord('\r') : None      # Deleted
}

a = s.translate(remap)
print('whitespace remapped:', a) # whitespace remapped: pýtĥöñ is awesome

# (b) Remove all combining characters/marks
import unicodedata
import sys
cmb_chrs = dict.fromkeys(c for c in range(sys.maxunicode)
                         if unicodedata.combining(chr(c))) # chr(): ASCII --&gt; character, ord(): character --&gt; ASCII

b = unicodedata.normalize('NFD', a)
c = b.translate(cmb_chrs)
print('accents removed:', c) # accents removed: python is awesome

# (c) Accent removal using I/O decoding
d = b.encode('ascii','ignore').decode('ascii')
print('accents removed via I/O:', d) # accents removed via I/O: python is awesome
</code></pre></li>
</ul>
<h2 id="213-aligning-text-strings"><a name="user-content-213-aligning-text-strings" href="#213-aligning-text-strings" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.13 Aligning Text Strings</h2>
<ul>
<li>
<p>The <em>ljust()</em>, <em>rjust()</em> and <em>center()</em> methods of strings can be used.<br />
<pre><code class="python"># ljust, rjust and center function
text = &quot;Hello World&quot;
print(text.ljust(20))
print(text.rjust(20))
print(text.center(20))
# Result
# Hello World
#          Hello World
#     Hello World

print(text.rjust(20, '='))
print(text.center(20, '*'))
# Result
# =========Hello World
# ****Hello World*****
</code></pre></p>
</li>
<li>
<p>The <em>format()</em> function can also be used to easily align things. All you need to do is use the <strong>&lt;</strong>, <strong>&gt;</strong> or <strong>^</strong> characters along with a desired width. </p>
</li>
<li>These format codes can also be used in the <em>format()</em> method when formatting multiple values.</li>
<li>The <em>format()</em> function works with any value, making it more general purpose.<br />
<pre><code class="python"># format function
text = &quot;Hello World&quot;
print(format(text, '&lt;20'))
print(format(text, '&gt;20'))
print(format(text, '^20'))
# Result
# Hello World
#          Hello World
#     Hello World

print(format(text, '=&gt;20'))
print(format(text, '*^20'))
# Result
# =========Hello World
# ****Hello World*****

print('{:&gt;10} {:&gt;10}'.format('Hello', 'World'))
#      Hello      World
</code></pre></li>
</ul>
<h2 id="214-combining-and-concatenating-strings"><a name="user-content-214-combining-and-concatenating-strings" href="#214-combining-and-concatenating-strings" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.14 Combining and Concatenating Strings</h2>
<ul>
<li>
<p>The fastest way to combine them is to use the <em>join()</em> method.<br />
<pre><code class="python"># join function
parts = ['Is', 'Chicago', 'Not', 'Chicago?']
print(' '.join(parts))
print(','.join(parts))
print(''.join(parts))
# Result
# Is Chicago Not Chicago?
# Is,Chicago,Not,Chicago?
# IsChicagoNotChicago?
</code></pre></p>
</li>
<li>
<p>If you&rsquo;re only combining a few strings, using <strong>+</strong> usually works well enough.<br />
<pre><code class="python"># '+'
a = 'Is Chicago'
b = 'Not Chicago?'
print(a + ' ' + b)
# Is Chicago Not Chicago?
</code></pre></p>
</li>
<li>
<p>The + operator also works fine as a substitute for more complicated string formatting operations.<br />
<pre><code class="python"># fomat function
a = 'Is Chicago'
b = 'Not Chicago?'
print('{} {}'.format(a,b))
# Is Chicago Not Chicago?
</code></pre></p>
</li>
<li>
<p>You could come up with some kind of hybrid scheme that&rsquo;s smart about combining I/O operations.<br />
<pre><code class="python">def sample():
    yield 'ls'
    yield 'Chicago'
    yield 'Not'
    yield 'Chicago?'

def combine(source, maxsize):
    parts = []
    size = 0
    for part in source:
        parts.append(part)
        size += len(part)
        if size &gt; maxsize :
            yield ' '.join(parts)
            parts = []
            size = 0
    yield ' '.join(parts)

for part in combine(sample(), 32768):
    print(part)
# ls Chicago Not Chicago?
</code></pre></p>
</li>
</ul>
<h2 id="215-interpolating-variables-in-strings"><a name="user-content-215-interpolating-variables-in-strings" href="#215-interpolating-variables-in-strings" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.15 Interpolating Variables in Strings</h2>
<ul>
<li>
<p>Python has no direct support for simply substituting variable values in string. However, this feature can be approximated using the <em>format()</em> method of strings.<br />
<pre><code class="python"># format()
s = '{name} has {n} messages.'
print(s.format(name='Demon', n = 25)) # Demon has 25 messages.
</code></pre></p>
</li>
<li>
<p>Alternatively, if the values to be substituted are truly found in variables, you can use the combination of <em>format_map()</em> and <em>vars()</em>.<br />
<pre><code class="python"># format_map() and vars()
name = 'Demon'
n = 26
print(s.format_map(vars())) # Demon has 26 messages.

class Info:
    def __init__(self, name, n):
        self.name = name
        self.n = n

a = Info('Demon', 27)
print(s.format_map(vars(a))) # Demon has 27 messages.
</code></pre></p>
</li>
<li>
<p>One downside of <em>format()</em> and <em>format_map()</em> is that they do not deal gracefully with missing values.<br />
<pre><code class="python">print(s.format(name='Demon'))
# Error！！！
# Traceback (most recent call last):
#   File &quot;F:\study\Python\test.py&quot;, line 16, in &lt;module&gt;
#     print(s.format(name='Demon'))
# KeyError: 'n'
</code></pre></p>
</li>
<li>
<p>One way to avoid this is to define an alternative dictionary class with a <em><strong>missing</strong>()</em> method.<br />
<pre><code class="python"># __missing__()
s = '{name} has {n} messages.'
class safesub(dict):
    def __missing__(self, key):
        return '{' + key + '}' # When missing key value, return its prototype with &quot;{}&quot;.

name = 'Demon'
print(s.format_map(safesub(vars()))) # Demon has {n} messages.
</code></pre></p>
</li>
<li>
<p>If you find yourself frequently performing these steps in your code, you could hide the variable substitution process behind a small utility function that employs a so-called &ldquo;frame hack&rdquo;.</p>
</li>
<li>
<p>The <em>sys._getframe(1)</em> to return the stack frame of the caller. From that, the <em>f_locals</em> attribute is accessed to get the local variables.<br />
<pre><code class="python"># frame hack: sys._getframe(1)
class safesub(dict):
    def __missing__(self, key):
        return '{' + key + '}'

import sys
def sub(text):
    return text.format_map(safesub(sys._getframe(1).f_locals)) # return the stack frame of the caller

name = 'Demon'
n = 37
print(sub('Hello {name}'))
print(sub('You have {n} messages.'))
print(sub('You favorite color is {color}'))

#Result
# Hello Demon
# You have 37 messages.
# You favorite color is {color}
</code></pre></p>
</li>
<li>
<p>You may also see string formattng like this.<br />
<pre><code class="python">name = 'Demon'
n = 55
import string
s = string.Template('$name has $n message')
print(s.substitute(vars())) # Demon has 55 message
</code></pre></p>
</li>
</ul>
<h2 id="216-reformating-text-to-a-fixed-number-of-coloumns"><a name="user-content-216-reformating-text-to-a-fixed-number-of-coloumns" href="#216-reformating-text-to-a-fixed-number-of-coloumns" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.16 Reformating Text to a Fixed Number of coloumns</h2>
<ul>
<li>
<p>Use the <em>textwrap</em> module to reformat text for output.<br />
<pre><code class="python">s = &quot;Look into my eyes, look into my eyes, the eyes, the eyes, \
the eyes, not around the eyes, don't look around the eyes, \
look into my eyes, you're under.&quot;
print(s)

import textwrap
print(textwrap.fill(s, 70))
print(textwrap.fill(s, 40))
print(textwrap.fill(s, 40, initial_indent = '       '))
print(textwrap.fill(s, 40, subsequent_indent = '        '))

# Look into my eyes, look into my eyes, the eyes, the eyes, the eyes, not around the eyes, don't look around the eyes, look into my eyes, you're under.
#
# Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,
# not around the eyes, don't look around the eyes, look into my eyes,
# you're under.
#
# Look into my eyes, look into my eyes,
# the eyes, the eyes, the eyes, not around
# the eyes, don't look around the eyes,
# look into my eyes, you're under.
#
#        Look into my eyes, look into my
# eyes, the eyes, the eyes, the eyes, not
# around the eyes, don't look around the
# eyes, look into my eyes, you're under.
#
# Look into my eyes, look into my eyes,
#         the eyes, the eyes, the eyes,
#         not around the eyes, don't look
#         around the eyes, look into my
#         eyes, you're under.
</code></pre></p>
</li>
<li>
<p>On the subject of the terminal size, you can obtain it using <em>os.get_terminal_size()</em>.<br />
<pre><code class="python">import os
os.get_terminal_size().columns # 80
</code></pre></p>
</li>
<li>
<p>Look at the documentation for the <em>textwrap.TextWrapper</em> class for further details.</p>
</li>
</ul>
<h2 id="217-handling-html-and-xml-entities-in-text"><a name="user-content-217-handling-html-and-xml-entities-in-text" href="#217-handling-html-and-xml-entities-in-text" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.17 Handling HTML and XML Entities in Text</h2>
<ul>
<li>
<p>If you are producing text, replacing special characters such as &ldquo;&lt;&rdquo; or &ldquo;&gt;&rdquo; is relatively easy if you use the <em>html.escape()</em> function.<br />
<pre><code class="python">s = 'Elements are written as &quot;&lt;tag&gt;text&lt;/tag&gt;&quot;'
print(s)

import html
print(html.escape(s))
print(html.escape(s, quote = False))

# Elements are written as &quot;&lt;tag&gt;text&lt;/tag&gt;&quot;
# Elements are written as &amp;quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&amp;quot;
# Elements are written as &quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&quot;
</code></pre></p>
</li>
<li>
<p>If you&rsquo;re trying to emit text as ASCII and want to embed character code entities for non-ASCII characters, you can use the <em>errors = &lsquo;xmlcharrefreplace&rsquo;</em> argument to various I/O-related fucntions to do it.<br />
<pre><code class="python">s1 = 'Spicy Jalape\u00f1o'
print(s1.encode('ascii', errors='xmlcharrefreplace'))
# b'Spicy Jalape&amp;#241;o'
</code></pre></p>
</li>
<li>
<p>If you&rsquo;ve received bare text with some entities in it and you want them replaced manually, you can usually do it using various utility functions/methods associated with HTML or XML parsers.<br />
<pre><code class="python">s2 = 'Spicy &amp;quot;Jalape&amp;#241;o&amp;quot.'
from html.parser import HTMLParser
p = HTMLParser()
print(p.unescape(s2))
# Spicy &quot;Jalapeño&quot;

t = 'The prompt is &amp;gt;&amp;gt;&amp;gt;'
from xml.sax.saxutils import unescape
print(unescape(t))
# The prompt is &gt;&gt;&gt;
</code></pre></p>
</li>
</ul>
<h2 id="218-tokenizing-text"><a name="user-content-218-tokenizing-text" href="#218-tokenizing-text" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.18 Tokenizing Text</h2>
<ul>
<li>The first step is to define all of the possible tockens, including whitespace, by regular expression patterns using named capture groups.</li>
<li>
<p>Next, to tokenize, use the little-known <em>scanner()</em> method of pattern objects. This method creates a scanner object in which repeated calls to <em>match()</em> step through the supplied text one match at a time.<br />
<pre><code class="python">import re

# The ?P&lt;TOKENNAME&gt; convention is used to assign a name to pattern.
NAME = r'(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)'
NUM = r'(?P&lt;NUM&gt;\d+)'
PLUS = r'(?P&lt;PLUS&gt;\+)'
TIMES = r'(?P&lt;TIMES&gt;\*)'
EQ = r'(?P&lt;EQ&gt;=)'
WS = r'(?P&lt;WS&gt;\s+)'

master_pat = re.compile('|'.join([NAME, NUM, PLUS, TIMES, EQ, WS]))

scanner = master_pat.scanner('foo = 42')
</code></pre></p>
</li>
<li>
<p>Run the module, and run codes as follow in Shell<br />
<pre><code class="python">&gt;&gt;&gt; scanner.match()
&lt;_sre.SRE_Match object; span=(0, 3), match='foo'&gt;
&gt;&gt;&gt; _.lastgroup, _.group()
('NAME', 'foo')
&gt;&gt;&gt; scanner.match()
&lt;_sre.SRE_Match object; span=(3, 4), match=' '&gt;
&gt;&gt;&gt; _.lastgroup, _.group()
('WS', ' ')
&gt;&gt;&gt; scanner.match()
&lt;_sre.SRE_Match object; span=(4, 5), match='='&gt;
&gt;&gt;&gt; _.lastgroup, _.group()
('EQ', '=')
&gt;&gt;&gt; scanner.match()
&lt;_sre.SRE_Match object; span=(5, 6), match=' '&gt;
&gt;&gt;&gt; _.lastgroup, _.group()
('WS', ' ')
&gt;&gt;&gt; scanner.match()
&lt;_sre.SRE_Match object; span=(6, 8), match='42'&gt;
&gt;&gt;&gt; _.lastgroup, _.group()
('NUM', '42')
&gt;&gt;&gt; scanner.match()
&gt;&gt;&gt; 
</code></pre></p>
</li>
<li>
<p>To take this technique and put it into code, it can be cleaned up and easily packaged into a generator.<br />
<pre><code class="python">import re

# The ?P&lt;TOKENNAME&gt; convention is used to assign a name to pattern.
NAME = r'(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)'
NUM = r'(?P&lt;NUM&gt;\d+)'
PLUS = r'(?P&lt;PLUS&gt;\+)'
TIMES = r'(?P&lt;TIMES&gt;\*)'
EQ = r'(?P&lt;EQ&gt;=)'
WS = r'(?P&lt;WS&gt;\s+)'

master_pat = re.compile('|'.join([NAME, NUM, PLUS, TIMES, EQ, WS]))

from collections import namedtuple

Token = namedtuple('Token', ['type', 'value'])

def generate_tokens(pat, text):
    scanner = pat.scanner(text)
    for m in iter(scanner.match, None):
        yield Token(m.lastgroup, m.group())

for tok in generate_tokens(master_pat, 'foo = 42'):
    print(tok)

# Token(type='NAME', value='foo')
# Token(type='WS', value=' ')
# Token(type='EQ', value='=')
# Token(type='WS', value=' ')
# Token(type='NUM', value='42')
</code></pre></p>
</li>
<li>
<p>There are a few important details to keep in mind.</p>
</li>
<li>Make sure that you identify every possible text sequence that might appear in the input with a corresponding <em>re</em> pattern. If any nonmatching text is found, scanning simply stops.</li>
<li>When matching, <em>re</em> tries to match patterns in the order specified. Thus, if a pattern happens to be a substring of a longer pattern, you need to make sure the longer pattern goes first.</li>
<li>Watch out for patterns that form substrings.</li>
</ul>
<h2 id="219-writing-a-simple-recursive-descent-parser"><a name="user-content-219-writing-a-simple-recursive-descent-parser" href="#219-writing-a-simple-recursive-descent-parser" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.19 Writing a Simple Recursive Descent Parser</h2>
<ul>
<li>You need to parse text according to a set of grammer rules and preform actions or build an abstract syntax tree representing the input.</li>
<li>
<p>Parsing involves tyring to match the grammer to input tokens by making substitutions.<br />
<pre><code class="txt">expr
expr ::= term { (+|-) term }*
expr ::= factor { (*|/) factor }* { (+|-) term }*
expr ::= NUM { (*|/) factor }* { (+|-) term }*
expr ::= NUM { (+|-) term }*
expr ::= NUM + term { (+|-) term }*
expr ::= NUM + factor { (*|/) factor }* { (+|-) term }*
expr ::= NUM + NUM { (*|/) factor}* { (+|-) term }*
expr ::= NUM + NUM * factor { (*|/) factor }* { (+|-) term }*
expr ::= NUM + NUM * NUM { (*|/) factor }* { (+|-) term }*
expr ::= NUM + NUM * NUM { (+|-) term }*
expr ::= NUM + NUM * NUM
</code></pre><br />
<pre><code class="python">import re
import collections

NUM     = r'(?P&lt;NUM&gt;\d+)'
PLUS    = r'(?P&lt;PLUS&gt;\+)'
MINUS   = r'(?P&lt;MINUS&gt;-)'
TIMES   = r'(?P&lt;TIMES&gt;\*)'
DIVIDE  = r'(?P&lt;DIVIDE&gt;/)'
LPAREN  = r'(?P&lt;LPAREN&gt;\()'
RPAREN  = r'(?P&lt;RPAREN&gt;\))'
WS      = r'(?P&lt;WS&gt;\s+)'

master_pat = re.compile('|'.join([NUM, PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN, WS]))

Token = collections.namedtuple('Token',['type', 'value'])

def generate_tokens(text):
    scanner = master_pat.scanner(text)
    for m in iter(scanner.match, None):
        tok = Token(m.lastgroup, m.group())
        if tok.type != 'WS':
            yield tok

class ExpressionEvaluator:
    '''
    Implementation of a recursive descent parser. Each method implements a single grammer rule.
    Use the ._accept() method to test and accept the current lookahead token. Use the ._expect()
    method to exactly match and discard the next token on the input (or raise a SyntaxError if it
    doesn't match).
    '''

    def parse(self, text):
        self.tokens = generate_tokens(text)
        self.tok = None
        self.nexttok = None
        self._advance()
        return self.expr()

    def _advance(self):
        'Advance one token ahead'
        self.tok, self.nexttok = self.nexttok, next(self.tokens, None)

    def _accept(self, toktype):
        'Test and consume the next token if it matches toktype'
        if self.nexttok and self.nexttok.type == toktype:
            self._advance()
            return True
        else:
            return False

    def _expect(self, toktype):
        'Consume next token if it matches toktype or raise SyntaxError'
        if not self._accept(toktype):
            raise SyntaxError('Expected ' + toktype)

    def expr(self):
        &quot;expression ::= term {('+' | '-') term}*&quot;

        exprval = self.term()
        while self._accept('PLUS') or self._accept('MINUS'):
            op = self.tok.type
            right = self.term()
            if op == 'PLUS':
                exprval += right
            elif op == 'MINUS':
                exprval -= right
        return exprval

    def term(self):
        &quot;term ::= factor {('*' | '/') factor}*&quot;

        termval = self.factor()
        while self._accept('TIMES') or self._accept('DIVIDE'):
            op = self.tok.type
            right = self.factor()
            if op == 'TIMES':
                termval *= right
            elif op == 'DIVIDE':
                termval /= right
        return termval

    def factor(self):
        &quot;factor ::= NUM | ( expr )&quot;

        if self._accept('NUM'):
            return int(self.tok.value)
        elif self._accept('LPAREN'):
            exprval = self.expr()
            self._expect('RPAREN')
            return exprval
        else:
            raise SyntaxError('Expected NUMBER or LPAREN')

e = ExpressionEvaluator()
print(e.parse('2'))
print(e.parse('2 + 3'))
print(e.parse('2 + 3 * 4'))
print(e.parse('2 + (3 + 4) * 5'))
print(e.parse('2 + 3 + * 4'))

# 2
# 5
# 14
# 37
# Traceback (most recent call last):
#   File &quot;F:\Learning\Python\Cookbook\test.py&quot;, line 99, in &lt;module&gt;
#     print(e.parse('2 + 3 + * 4'))
#   File &quot;F:\Learning\Python\Cookbook\test.py&quot;, line 37, in parse
#     return self.expr()
#   File &quot;F:\Learning\Python\Cookbook\test.py&quot;, line 62, in expr
#     right = self.term()
#   File &quot;F:\Learning\Python\Cookbook\test.py&quot;, line 72, in term
#     termval = self.factor()
#   File &quot;F:\Learning\Python\Cookbook\test.py&quot;, line 92, in factor
#     raise SyntaxError('Expected NUMBER or LPAREN')
# SyntaxError: Expected NUMBER or LPAREN
</code></pre></p>
</li>
<li>
<p>Here is an alternative implementation that constructs a simple parse tree.<br />
<pre><code class="python">class ExpressionTreeBuilder(ExpressionEvaluator):
    def expr(self):
        &quot;expression ::= term {('+' | '-') term}&quot;

        exprval = self.term()
        while self._accept('PLUS') or self._accept('MINUS'):
            op = self.tok.type
            right = self.term()
            if op == 'PLUS':
                exprval = ('+', exprval, right)
            elif op == 'MINUS':
                exprval = ('-', exprval, right)
        return exprval

    def term(self):
        &quot;term ::= factor {('*' | '/') factor}&quot;

        termval = self.factor()
        while self._accept('TIMES') or self._accept('DIVIDE'):
            op = self.tok.type
            right = self.factor()
            if op == 'TIMES':
                termval = ('*', termval, right)
            elif op == 'DIVIDE':
                termval = ('/', termval, right)
        return termval

    def factor(self):
        &quot;factor ::= NUM| ( expr )&quot;

        if self._accept('NUM'):
            return int(self.tok.value)
        elif self._accept('LPAREN'):
            exprval = self.expr()
            self._expect('RPAREN')
            return exprval
        else:
            raise SyntaxError('Expected NUMBER or LPAREN')

e = ExpressionTreeBuilder()

print(e.parse('2 + 3'))
print(e.parse('2 + 3 * 4'))
print(e.parse('2 + (3 + 4) * 5'))
print(e.parse('2 + 3 + 4'))

# ('+', 2, 3)
# ('+', 2, ('*', 3, 4))
# ('+', 2, ('*', ('+', 3, 4), 5))
# ('+', ('+', 2, 3), 4)
</code></pre></p>
</li>
</ul>
<h2 id="220-performing-text-operations-on-byte-strings"><a name="user-content-220-performing-text-operations-on-byte-strings" href="#220-performing-text-operations-on-byte-strings" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.20 Performing Text Operations on Byte Strings</h2>
<ul>
<li>For the most part, almost all of the operations available on text strings will work on byte strings.</li>
<li>However, there are a few notable differences to be aware of.</li>
<li>Indexing of byte strings produces integers, not individual characters.</li>
<li>Byte strings don&rsquo;t provide a nice string representation and don&rsquo;t print cleanly unless first decoded into a text string.</li>
<li>There are no string formatting operations available to byte strings.</li>
<li>If you want to do any kind of formatting applied to byte strings, it should be done using normal text strings and encoding.</li>
<li>You need to be aware that using a byte string can change the semantics of certain operations &ndash; especially those related to filesystem.<br />
<pre><code class="python">b = b'Hello World'
print(b[0], b[1]) # 72 101

print(b) # b'Hello World'
print(b.decode('ascii')) # Hello World

print('{:10s} {:10d} {:10.2f}'.format('ACME', 100, 490.1).encode('ascii'))
# b'ACME              100     490.10'

with open('jalape\xf1o.txt', 'w') as f:
    f.write('spicy')

import os
print(os.listdir('.')) # 'jalapeño.txt'
print(os.listdir(b'.')) # b'jalapen\xcc\x83o.txt'
</code></pre></li>
</ul></article></body></html>